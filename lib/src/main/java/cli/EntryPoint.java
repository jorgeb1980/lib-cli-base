package cli;

import cli.annotations.Command;
import cli.annotations.OptionalArgs;
import cli.annotations.Parameter;
import org.apache.commons.cli.*;

import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;

import static java.lang.String.format;

/**
 * Common launcher for all the commands. 
 */
class EntryPoint {

	//------------------------------------------------------------
	// Class constants
	
	// Output encoding
	public static final Charset ENCODING = StandardCharsets.UTF_8;
	
	//------------------------------------------------------------
	// Class properties

	// Logger
	private final static Logger logger = Logger.getLogger(EntryPoint.class.getName());
	// Program's own standardOutput
	private final ByteArrayOutputStream stdBytes = new ByteArrayOutputStream();
	private final PrintWriter standardOutput = new PrintWriter(new OutputStreamWriter(stdBytes, ENCODING)
	);
	private final ByteArrayOutputStream errBytes = new ByteArrayOutputStream();
	// Program's own errorOutput
	private final PrintWriter errorOutput = new PrintWriter(new OutputStreamWriter(errBytes, ENCODING)
	);
	
	//------------------------------------------------------------
	// Class methods	
	
	/**
	 * Entry point for the command launcher.
	 * @param args Command arguments
	 */
	public static void main(String[] args) {
		//LogUtils.setupLogs();
		int ret = 0;
		try (var s = new Stopwatch("Total time")) {
			Path currentPath = Paths.get("").toAbsolutePath();
			String command = head(args);
			List<String> rest = tail(args);
			// Special case: when asked for --help, print the help straight now
			if (rest.size() == 1 && rest.contains("--help")) {
				printHelp(command);
			} else {
				EntryPoint entry = new EntryPoint();
				ret = entry.executeEntryPoint(command, rest, currentPath);
				entry.flush(false);
			}
		} catch (CmdException cmde) {
			logger.log(Level.SEVERE, cmde.getMessage(), cmde);
			System.exit(cmde.getReturnCode());
		}
		// The command returned some exit code, this is our return code
		System.exit(ret);
	}
	
	// Prints the help generated by Apache Commons Cli for the specified
	//	command
	@SuppressWarnings({"rawtypes", "unchecked"})
	private static void printHelp(String commandClassName) throws CmdException {
		var introspection = new Introspection(commandClassName);
		Class commandClass = introspection.getCommandClass();
		Options options = buildOptions(commandClass);
		String optionalArg = lookForOptionalArgs(commandClass);
		String commandName = 
				((Command)commandClass.getAnnotation(Command.class)).command();
		String commandDescription = 
				((Command)commandClass.getAnnotation(Command.class)).description();
		String footer = "\nv%s";
		 
		HelpFormatter formatter = new HelpFormatter();
		if (optionalArg != null) {
			// Format the usage in order to show a list of arguments if necessary
			ByteArrayOutputStream baos = new ByteArrayOutputStream();
			OutputStreamWriter writer = new OutputStreamWriter(baos, StandardCharsets.UTF_8);
			PrintWriter pwTemp = new PrintWriter(writer);
			formatter.printUsage(pwTemp, 120, "ls", options);
			pwTemp.flush();
			StringBuilder sb = new StringBuilder(baos.toString(StandardCharsets.UTF_8));
			sb.append(format(" [%s]...", optionalArg));
			String usage = sb.toString().replaceAll("[\r\n]", "");
			usage = usage.replace("usage:", "");
			formatter.printHelp(
				usage, 
				commandDescription, 
				options, 
				format(footer, getVersion()),
				false);
		}
		else {
			formatter.printHelp(
				commandName, 
				commandDescription, 
				options, 
				format(footer, getVersion()),
				true);
		}
	}

	// Looks for an OptionalArgs annotation; it means that the command accepts
	//	additional arguments such as ls or df.
	// It returns the name argument of the OptionalArgs annotation or null if
	//	not found
	private static String lookForOptionalArgs(@SuppressWarnings("rawtypes") Class commandClass) {
		Field[] fields = commandClass.getDeclaredFields();
		String ret = null;
		for (Field field: fields) {
			if (field.isAnnotationPresent(OptionalArgs.class)) {
				OptionalArgs annotation = field.getAnnotation(OptionalArgs.class);
				ret = annotation.name();
			}
		}
		return ret;
	}

	// Gets the current application version from the cli.properties file
	private static String getVersion() {
		String ret = "";
		try (InputStream is = EntryPoint.class.getClassLoader().
				getResourceAsStream("cli.properties")) {
			Properties prop = new Properties();
			prop.load(is);
			ret = prop.getProperty("cli.version");
		}
		catch(Exception e) {
			// No version
			ret = "undetermined";
		}
		return ret;
	}

	// Initializes an entry point with its proper standard and error output
	//	buffers
	public EntryPoint() { }

	/**
	 * Flush the content of the output buffers to the real standard
	 * and error output.
	 */
	public void flush(boolean error) {
		standardOutput.flush();
		System.out.print(stdBytes.toString(ENCODING));
		if (error) {
			errorOutput.flush();
			System.err.print(errBytes.toString(ENCODING));
		}
	}

	/**
	 * Executes a command with certain parameters and path.
	 * @param command Name of the command to execute.
	 * @param commandArguments Arguments for the command.
	 * @param currentPath File path where the command is executed.
	 * @throws CmdException if any error is reached during the execution.
	 */
	public int executeEntryPoint(String command, List<String> commandArguments, Path currentPath) 
			throws CmdException {
		int ret = 0;
		if (command != null) {
			var introspection = new Introspection(command);
			try (var s = new Stopwatch("execute command")) {
				ret = executeCommand(
					introspection.getCommand(),
					introspection.getMethod(),
					currentPath,
					commandArguments
				);
			}
		}
		else {
			throw new CmdException("Please specify which command you wish to launch", -1);
		}
		return ret;
	}
	
	// Executes the line command, returning the exit code
	private Integer executeCommand(
			Object command, 
			Method execute, 
			Path currentPath,
			List<String> args) throws CmdException {
		Object ret;
		try {
			// Every command should have an execute method with:
			// + Current path for the command
			CommandLine commandLine =  new DefaultParser().parse(
				buildOptions(command.getClass()), 
				args.toArray(new String[args.size()]),
				// Fail if there is something unrecognized
				false);
			applyArguments(command, commandLine);
			// Apply the command line to the command
			ret = execute.invoke(command, new ExecutionContext(currentPath, standardOutput, errorOutput));
		} 
		catch (IllegalAccessException 
				| IllegalArgumentException 
				| InvocationTargetException
				| ParseException e) {
			throw new CmdException(e).setReturnCode(-1337);
		}
		return (Integer) ret;
	}
	
	// This method applies every argument in the command line to the command object
	private void applyArguments(Object command, CommandLine commandLine) 
			throws IllegalAccessException, InvocationTargetException {
		// Map the setter methods to commandLine option names
		Method[] methods = command.getClass().getMethods();
		Field[] fields = command.getClass().getDeclaredFields();
		Map<String, Method> methodsMap = new HashMap<>();
		Method optionalArgsMethod = null;
		for (Field field: fields) {			
			Method method = lookForSetter(field, methods);
			if (field.isAnnotationPresent(Parameter.class)) {
				Parameter parameter = field.getAnnotation(Parameter.class);
				if (parameter.name().trim().length() != 0) {
					methodsMap.put(parameter.name(), method);
				}
				if (parameter.longName().trim().length() != 0) {
					methodsMap.put(parameter.longName(), method);
				}
				
			}
			else if (method != null && field.isAnnotationPresent(OptionalArgs.class)) {
				optionalArgsMethod = method;
			}
		}
		// Apply the command line values to the indexed methods
		// Every method is supposed to be a simple setter with one argument, of
		//		one of the following types :
		//	String
		//	Integer
		//	Long
		//	Double
		//	Float
		// An argument-less parameter is supposed to be a Boolean, and if it is
		//	present, it is assumed to be true
		
		for (Option option: commandLine.getOptions()) {
			Method method = methodsMap.get(option.getArgName());
			if (method == null) {
				method = methodsMap.get(option.getLongOpt());
			}
			if (method != null) {
				method.invoke(command, processArgument(method, option.getValue()));
			}
		}
		if (optionalArgsMethod != null) {
			// The method must exist and admit a list of strings as its only
			//	parameter
			List<String> args = Arrays.asList(commandLine.getArgs());
			if (args.size() > 0) {
				optionalArgsMethod.invoke(command, args);
			}
		}
	}

	// Gets a string, sets all the string to lower case, then the first
	//	character to upper case.
	private String firstInUpperCase(String fieldName) {
		return fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1);
	}
	
	// Looks for the setter method of a class field
	private Method lookForSetter(Field field, Method[] methods) {
		Method ret = null;
		if (field != null && methods != null && methods.length > 0) {
			int i = 0;
			String expectedMethodName = "set" + firstInUpperCase(field.getName());
			while (ret == null && i < methods.length) {
				Method method = methods[i++];
				if (method.getName().equals(expectedMethodName)) {
					ret = method;
				}
			}
		}
		return ret;
	}

	// This method processes the option value in order to pass the right type
	//	to the command object
	private Object processArgument(Method method, String value) {
		Object ret = null;
		Class<?>[] types = method.getParameterTypes();
		if (types.length == 1) {
			Class<?> type = types[0];
			if (type.equals(String.class)) {
				ret = value;
			}
			else if (type.equals(Integer.class)) {
				ret = Integer.valueOf(value);
			}
			else  if (type.equals(Long.class)) {
				ret = Long.valueOf(value);
			}
			// This can be improved by looking closely at precision, etc.
			else  if (type.equals(Double.class)) {
				ret = Double.valueOf(value);
			}
			else  if (type.equals(Float.class)) {
				ret = Float.valueOf(value);
			}
			// Boolean arguments
			else if (type.equals(Boolean.class)) {
				// If value here is null or empty, it is assumed to be true
				if (value == null || value.trim().length() == 0) {
					ret = Boolean.TRUE;
				}
				else {
					ret = Boolean.valueOf(value);
				}
			}
		}
		return ret;
	}

	// This method build an Apache Command Line Options object upon
	//	the annotated parameters information in the class
	public static Options buildOptions(Class<?> commandClass) {
		//Method[] methods = commandClass.getMethods();
		// It will be the fields that get annotated, and those fields will get
		//	us to the setter method
		Field[] fields = commandClass.getDeclaredFields();
		Options options = new Options();
		for (Field field: fields) {
			if (field.isAnnotationPresent(Parameter.class)) {
				Parameter parameter = field.getAnnotation(Parameter.class);
				// Look for the corresponding setter method
				//Method method = lookForSetter(field, methods);
				if (parameter.name().trim().length() == 0) {
					options.addOption(
						Option.builder().
							hasArg(parameter.hasArg()).
							desc(parameter.description()).
							longOpt(parameter.longName()).build());
				}
				else {
					options.addOption(
						parameter.name(), 
						parameter.longName().trim().length()==0?parameter.name():parameter.longName(), 
						parameter.hasArg(), 
						parameter.description());
				}
			}
		}
		return options;
	}

	/** Returns the first argument */
	public static String head(String[] args) {
		String ret = null;
		if (args !=  null && args.length > 0) {
			ret = args[0];
		}
		return ret;
	}
	
	/** Returns the second and later arguments*/
	public static List<String> tail(String[] args) {
		List<String> ret  = new LinkedList<>();
		if (args != null && args.length > 1) {
			ret.addAll(Arrays.asList(args).subList(1, args.length));
		}
		return ret;
	}
}
